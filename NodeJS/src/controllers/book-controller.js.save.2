const { Sequelize, Model, DataTypes } = require("sequelize");
const sequelize = new Sequelize("postgres://kronk:GfEuJUBq37jWU3tgD48mHQ2@localhost:5432/bookchain_test");

const db = require("../models");
const Books = require("../models/Books.js")(sequelize, DataTypes);
const Op = db.sequelize.Op;
const axios = require('axios');


const { Api, JsonRpc, RpcError } = require('eosjs');
const { JsSignatureProvider } = require('eosjs/dist/eosjs-jssig');      // development only
const fetch = require('node-fetch');                                    // node only; not needed in browsers
const { TextEncoder, TextDecoder } = require('util');                   // node only; native TextEncoder/Decoder

//CREATE
exports.create = (req, res) => {
  //Validate request
  if (!req.body.isbn) {
    res.status(400).send({
      message: "Content can not be empty!"
    });
    return;
  }
  //Load from req
  const isbn = req.body.isbn;
  const privateKeyPair = req.body.privateKey;
  const privateKey = privateKeyPair.split(':')[1];
  const accountName = privateKeyPair.split(':')[0];
  
  //Set up API
  const signatureProvider = new JsSignatureProvider([privateKey]);
  const rpc = new JsonRpc('http://127.0.0.1:8888', { fetch });
  
  const api = new Api({ rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder() });
  

  //GET OpenLibrary API
  axios.get(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&format=json&jscmd=data`).then(
    response => {
		//Blockchain Action
		(async () => {
			try {
			const result = await api.transact({
				actions: [{
					account: 'librarian',
					name: 'donate',
					authorization: [{
						actor: accountName,
						permission: 'active',
					}],
					data: {
						user: accountName,
						ISBN: parseInt(isbn),
					},
				}]
			}, {
				blocksBehind: 3,
				expireSeconds: 30,
			});
			} catch (e) {
  console.log('\nCaught exception: ' + e);
  if (e instanceof RpcError)
    console.log(JSON.stringify(e.json, null, 2));
}
		})();
      //get response, add to DB
        const data = response["data"][`ISBN:${isbn}`];
        console.log(JSON.stringify(data.authors));
        const book = {
            ISBN: isbn,
            Title: data.title,
            Authors: JSON.stringify(data.authors),
            Thumbnail_url: data.cover.large,
            Info_url: data.url,
            Cover_url: data.cover.medium,
            Publish_date: data.publish_date,
            Quantity: 1,
            Num_pages: data.number_of_pages,
            ID_json: JSON.stringify(data.identifiers),
            Description: JSON.stringify(data.excerpts)
        }

        Books.create(book)
          .then(data => {
            res.send(data);
          })
          .catch(err => {
            res.status(500).send({
              message:
                err.message || "Some error occurred while creating the Book."
          });
        });
  })
  .catch(error => {
    console.log(error);
  });
};

//FIND ONE
exports.findByIsbn = (req, res) => {
  const isbn = req.params.isbn;

  Books.findByPk(isbn)
    .then(data => {
      res.json(data);
  })
  .catch(err => {
    res.status(500).send({
      message: "Error retrieving Book with isbn=" + isbn
    });
  });
};

//FINDALL
exports.findAll = (req, res) => {
  //possibly find by author
  const title = req.query.title;
  var condition = title ? { author: `%${title}%` } : null;

  Books.findAll({ where: condition} )
    .then(data => {
      res.json(data);
    })
    .catch(err => {
      res.status(500).send({
        message:
          err.message || "Some error occurred while retrieving books."
      });
  });
}

//UPDATE
exports.updateQuantity = (req, res) => {
  const isbn = req.params.isbn;
  const quantity = req.body.quantity;
  const actionType = req.body.actionType //Either "retrieve" or "donate" string
  const privateKeyPair = req.body.privateKey;
 
  const privateKey = privateKeyPair.split(':')[1];
  const accountName = privateKeyPair.split(':')[0];
  
  //Set up API
  const signatureProvider = new JsSignatureProvider([privateKey]);
  const rpc = new JsonRpc('http://127.0.0.1:8888', { fetch });
  
  const api = new Api({ rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder() });
 

 Books.update({Quantity: quantity}, {
    where: { ISBN: isbn }
  })
    .then(num => {
      if (num == 1) {
        res.send({
          message: "Book was updated successfully."
        });

	//Perform Blockchain Action
	if(actionType == "retrieve"){
		(async () => {
			try {
				const result = await api.transact({
					actions: [{
						account: 'eosio.token',
						name: 'transfer',
					authorization: [{
						actor: accountName,
						permission: 'active',
					}],
					data: {
						from: accountName,
						to:'librarian',
						
						ISBN: parseInt(isbn),
					},
				}]
			}, {
				blocksBehind: 3,
				expireSeconds: 30,
			});
			} catch (e) {
  console.log('\nCaught exception: ' + e);
  if (e instanceof RpcError)
    console.log(JSON.stringify(e.json, null, 2));
}
		})();
	}else{

	}
      } else {
        res.send({
          message: `Cannot update Book with isbn=${isbn}. Either the book was not found or request body is empty!`
        });
      }
    })
    .catch(err => {
      res.status(500).send({
        message: "Error updating Book with isbn=" + isbn
      });
    });
};

//DELETE
exports.delete = (req, res) => {
  const isbn = req.params.isbn;

  Books.destroy({
    where: { ISBN: isbn }
  })
    .then(num => {
      if (num == 1) {
        res.send({
          message: "Book was deleted successfully!"
        });
      } else {
        res.send({
          message: `Cannot delete book with isbn=${isbn}.`
        });
      }
    })
    .catch(err => {
      res.status(500).send({
        message: "Could not delete Book with isbn=" + isbn
      });
    });
};

//REPORT MISSING
exports.reportMissing = (req,res) => {
	const isbn = req.body.isbn;
	const privateKey = "5K2E3LFQuBXgw9MfrC14oJ4puA9oNQn2UL3Lwo6eDont3eHbAxH";
	const accountName = "resolver";
//Set up API
  const signatureProvider = new JsSignatureProvider([privateKey]);
  const rpc = new JsonRpc('http://127.0.0.1:8888', { fetch });
  
  const api = new Api({ rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder() });

	//Blockchain Action
		(async () => {
			try {
			const result = await api.transact({
				actions: [{
					account: 'librarian',
					name: 'nullify',
					authorization: [{
						actor: accountName,
						permission: 'active',
					}],
					data: {
						user: accountName,
						ISBN: parseInt(isbn),
					},
				}]
			}, {
				blocksBehind: 3,
				expireSeconds: 30,
			});
			} catch (e) {
  console.log('\nCaught exception: ' + e);
  if (e instanceof RpcError)
    console.log(JSON.stringify(e.json, null, 2));
}
		})();
	
	
	Books.update({Quantity: 0}, {
    where: { ISBN: isbn }
  })
    .then(num => {
      if (num == 1) {
        res.send({
          message: "Book was updated successfully."
        });
      } else {
        res.send({
          message: `Cannot update Book with isbn=${isbn}. Either the book was not found or request body is empty!`
        });
      }
    })
    .catch(err => {
      res.status(500).send({
        message: "Error Nullifying Book with isbn=" + isbn
      });
    });
	
	
}


exports.balance = (req,res) => {
  const privateKeyPair = req.body.privateKey;
  const privateKey = privateKeyPair.split(':')[1];
  const accountName = privateKeyPair.split(':')[0];
  
  //Set up API
  const signatureProvider = new JsSignatureProvider([privateKey]);
  const rpc = new JsonRpc('http://127.0.0.1:8888', { fetch });
  const api = new Api({ rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder() });
  
  (async () => {
			try {
			const result = rpc.get_currency_balance('eosio.token', accountName, 'BOOK').then(result => res.send(result));
			} catch (e) {
  console.log('\nCaught exception: ' + e);
  if (e instanceof RpcError)
    console.log(JSON.stringify(e.json, null, 2));
}
		})();
	
}
